# Safarnak App - Cursor AI Configuration

## Project Context
You are working on **Safarnak**, a full-stack travel application with offline-first capabilities. This is a unified single-root monorepo with:
- **Client**: Expo React Native app (iOS/Android/Web) at root level
- **Worker**: Cloudflare Worker backend (`worker.ts`) at root level
- **Shared**: Database schemas (`drizzle/`) and GraphQL definitions (`graphql/`) at root level

## Architecture Overview
- **Frontend**: Expo Router + Redux Toolkit + Apollo Client + Drizzle ORM
- **Backend**: Cloudflare Workers + GraphQL Yoga + D1 Database + Drizzle ORM
- **Database**: SQLite (Expo SQLite locally, Cloudflare D1 in production)
- **State**: Redux with persistence, offline-first approach
- **Auth**: Token-based with offline fallback
- **Languages**: English + Persian (Farsi) with RTL support
- **Code Quality**: ESLint 9 (flat config) + Prettier + TypeScript strict mode

## Key Technologies
- React Native 0.81.5 + Expo 54
- TypeScript with strict mode
- Redux Toolkit + Redux Persist
- Apollo Client + GraphQL
- Drizzle ORM + SQLite
- Cloudflare Workers + D1
- react-i18next for i18n
- ESLint 9 + Prettier for code quality

## Project Structure
```
safarnak.app/
├── app/                   # Expo Router pages
├── components/            # UI components
├── api/                   # GraphQL client utilities
├── hooks/                 # Custom React hooks
├── store/                 # Redux store
├── redux/                 # Redux slices
├── assets/                # Images, fonts, etc.
├── android/               # Android native code
├── ios/                   # iOS native code
├── worker.ts              # Cloudflare Worker entry
├── drizzle/               # Database schemas & migrations
├── graphql/               # Shared GraphQL definitions
├── app.config.js          # Dynamic app configuration
├── eas.json               # EAS build profiles
├── wrangler.toml          # Cloudflare Worker config
├── drizzle.config.ts      # Database config
├── eslint.config.js       # ESLint flat config
├── .prettierrc            # Prettier config
└── package.json           # Root package config
```

## Path Aliases
- `@/*` → `./*` (root files)
- `@components/*` → `./components/*` (UI components)
- `@graphql/*` → `./graphql/*` (shared GraphQL definitions)

## Coding Standards

### TypeScript
- Use strict TypeScript configuration
- Prefer interfaces over types for object shapes
- Use path aliases instead of relative imports
- Always type function parameters and return values
- Use `any` only when absolutely necessary
- Use `unknown` for truly unknown types

### React/React Native
- Use functional components with hooks
- Prefer `useCallback` and `useMemo` for performance
- Use TypeScript for all component props
- Follow Expo Router conventions for navigation
- Use Redux Toolkit patterns for state management
- Implement proper error boundaries

### Database
- Use Drizzle ORM for all database operations
- Follow shared schema patterns in `drizzle/schema.ts`
- Use migrations for schema changes
- Prefer type-safe queries over raw SQL
- Handle offline/online sync gracefully

### GraphQL
- Use shared GraphQL definitions from `graphql/` directory
- Follow Apollo Client patterns for data fetching
- Use error policies for graceful error handling
- Implement proper loading states
- Use subscriptions for real-time updates

### Code Quality
- Follow ESLint flat config rules
- Use Prettier for consistent formatting
- Run `yarn lint:fix` before committing
- Run `yarn format` for code formatting
- Use `yarn type-check` to verify TypeScript

## Authentication Patterns
- Token-based authentication with offline fallback
- Use `AuthWrapper` component for route protection
- Store user data in both AsyncStorage and local database
- Implement proper error handling for auth failures
- Use PBKDF2 for password hashing

## State Management
- Use Redux Toolkit with persistence
- Implement offline middleware for network handling
- Use selective persistence (whitelist specific slices)
- Follow Redux best practices for actions and reducers
- Use proper selectors for efficient state access

## Database Patterns
- Use shared base schemas with environment extensions
- Implement proper migration strategies
- Use type-safe Drizzle queries
- Handle offline/online sync gracefully
- Use proper indexing for performance

## UI/UX Guidelines
- Follow atomic design principles
- Use custom components from `components/ui/`
- Implement proper loading and error states
- Support both light and dark themes
- Ensure RTL support for Persian language
- Use proper accessibility features

## Error Handling
- Use comprehensive error boundaries
- Implement proper error messages with i18n
- Handle network errors gracefully
- Use Apollo Client error policies
- Log errors appropriately

## Performance
- Use lazy loading for routes and components
- Implement proper memoization with React.memo
- Use Redux selectors for efficient state access
- Optimize images and assets
- Use proper bundle splitting

## Testing
- Write unit tests for utility functions
- Test components with React Testing Library
- Mock external dependencies properly
- Test offline scenarios
- Test both online and offline functionality

## Common Commands
```bash
# Development
yarn dev                    # Start both client and worker
yarn start                  # Start Expo dev server
yarn wrangler:dev          # Start worker dev server

# Database
yarn db:generate           # Generate migrations
yarn db:migrate            # Apply migrations
yarn db:studio             # Open Drizzle Studio

# Code Quality
yarn lint                  # Run ESLint
yarn lint:fix              # Fix ESLint issues
yarn format                # Format with Prettier
yarn type-check            # TypeScript type checking

# Deployment
yarn wrangler:deploy       # Deploy worker to Cloudflare
yarn build:debug           # Build debug Android app
yarn build:release         # Build release Android app
```

## File Naming Conventions
- Components: PascalCase (e.g., `AuthWrapper.tsx`)
- Hooks: camelCase starting with 'use' (e.g., `useAuth.ts`)
- Utilities: camelCase (e.g., `formatDate.ts`)
- Constants: SCREAMING_SNAKE_CASE (e.g., `API_ENDPOINTS.ts`)
- Types: PascalCase (e.g., `UserTypes.ts`)
- Worker files: camelCase (e.g., `worker.ts`)

## Import Order
1. React and React Native imports
2. Third-party library imports
3. Internal imports (using path aliases)
4. Relative imports
5. Type-only imports (with `type` keyword)

## Code Organization
- Group related functionality in feature folders
- Use index files for clean exports
- Keep components small and focused
- Extract reusable logic into custom hooks
- Use proper separation of concerns
- Keep worker code in `worker.ts`

## Security Considerations
- Validate all user inputs
- Use proper password hashing (PBKDF2)
- Implement secure token generation
- Handle sensitive data appropriately
- Follow OWASP security guidelines
- Use HTTPS in production

## Accessibility
- Use proper semantic HTML elements
- Implement proper ARIA labels
- Ensure keyboard navigation works
- Test with screen readers
- Maintain proper color contrast
- Support RTL layouts

## Internationalization
- Use react-i18next for all text content
- Support both LTR and RTL layouts
- Use proper date and number formatting
- Test with different languages
- Provide fallback translations
- Use proper Persian text handling

## When Making Changes
1. Follow existing patterns and conventions
2. Update types when changing interfaces
3. Add proper error handling
4. Include loading states where appropriate
5. Test both online and offline scenarios
6. Ensure i18n support for new text
7. Run linting and formatting
8. Update documentation if needed

## Common Patterns to Follow

### Component Pattern
```typescript
interface ComponentProps {
  // Define props with proper types
}

export default function Component({ prop1, prop2 }: ComponentProps) {
  // Use hooks at the top
  const { data, loading, error } = useQuery(QUERY);
  
  // Early returns for loading/error states
  if (loading) return <LoadingScreen />;
  if (error) return <ErrorScreen error={error} />;
  
  // Main component logic
  return (
    <View>
      {/* Component JSX */}
    </View>
  );
}
```

### Hook Pattern
```typescript
export function useCustomHook(param: string) {
  const [state, setState] = useState<StateType>(initialState);
  
  const handleAction = useCallback((value: string) => {
    // Action logic
  }, []);
  
  return { state, handleAction };
}
```

### Redux Slice Pattern
```typescript
interface SliceState {
  // Define state shape
}

const slice = createSlice({
  name: 'sliceName',
  initialState,
  reducers: {
    actionName: (state, action: PayloadAction<PayloadType>) => {
      // Reducer logic
    },
  },
});

export const { actionName } = slice.actions;
export default slice.reducer;
```

### Worker Pattern
```typescript
export interface Env {
  DB: D1Database;
  SUBSCRIPTION_POOL: DurableObjectNamespace;
}

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    // Worker logic
  },
};
```

## Environment-Specific Considerations

### Client (React Native)
- Use Expo APIs for platform-specific functionality
- Handle offline scenarios gracefully
- Implement proper error boundaries
- Use Redux for state management
- Support both iOS and Android

### Worker (Cloudflare Workers)
- Use Cloudflare-specific APIs
- Handle D1 database operations
- Implement GraphQL subscriptions
- Use proper error handling
- Optimize for edge computing

Remember: Always prioritize type safety, offline functionality, code quality, and user experience in this travel application.