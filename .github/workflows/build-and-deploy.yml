name: Build Android APK

on:
  push:
    branches: [master, main]
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  JAVA_VERSION: '17'
  GRADLE_OPTS: '-Dorg.gradle.daemon=true -Dorg.gradle.workers.max=4 -Dorg.gradle.parallel=true -Dorg.gradle.caching=true -Dorg.gradle.jvmargs=-Xmx4g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dkotlin.compiler.execution.strategy=in-process'

jobs:
  build-android:
    name: Build Android APK
    runs-on: ubuntu-latest
    timeout-minutes: 60
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: false
    permissions:
      contents: write
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history to properly detect commit messages
          fetch-tags: true  # Fetch all tags to properly detect last release

      - name: Free disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf "/usr/local/share/boost"
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"
          df -h

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'
          cache-dependency-path: yarn.lock

      # -----------------------
      # Versioning (no deps required)
      # -----------------------
      - name: Determine semantic version bump
        id: version_bump
        env:
          COMMIT_MSG: ${{ github.event.head_commit.message }}
        run: |
          node <<'NODE'
          const fs = require('fs');
          const cp = require('child_process');
          const pkg = JSON.parse(fs.readFileSync('package.json','utf8'));
          const current = pkg.version.trim();
          
          // Fetch all tags to get latest release (ensure we have all tags)
          try {
            cp.execSync('git fetch origin --tags --force 2>/dev/null', { stdio: 'ignore' });
            console.log('‚úÖ Fetched tags from origin');
          } catch (e) {
            console.log('‚ÑπÔ∏è  Could not fetch tags from origin, trying local tags...');
            try {
              cp.execSync('git fetch --tags --force 2>/dev/null', { stdio: 'ignore' });
            } catch (e2) {
              console.log('‚ÑπÔ∏è  Could not fetch tags, continuing with local tags...');
            }
          }
          
          // Get latest release tag (matching pattern vX.Y.Z)
          let lastTag = '';
          let lastTagVersion = '';
          try {
            const tags = cp.execSync('git tag --sort=-version:refname | grep -E "^v[0-9]+\\.[0-9]+\\.[0-9]+$" | head -n 1', { encoding: 'utf8' }).trim();
            if (tags) {
              lastTag = tags.split('\n')[0];
              lastTagVersion = lastTag.replace(/^v/, '');
              console.log(`üìã Found last release tag: ${lastTag} (version: ${lastTagVersion})`);
              
              // Verify the tag exists in the current repository
              try {
                cp.execSync(`git rev-parse ${lastTag}`, { stdio: 'ignore' });
                console.log(`‚úÖ Tag ${lastTag} verified in repository`);
              } catch (e) {
                console.log(`‚ö†Ô∏è  Tag ${lastTag} not found in repository, will use all commits`);
                lastTag = '';
                lastTagVersion = '';
              }
            } else {
              console.log('‚ÑπÔ∏è  No previous release tag found');
            }
          } catch (e) {
            console.log('‚ÑπÔ∏è  Error finding tags:', e.message);
          }
          
          // CRITICAL: Use lastTagVersion as base, NOT package.json current version
          // This prevents double-bumping when package.json was already updated
          const baseVersion = lastTagVersion || current;
          console.log(`\nüìå Base version for bump calculation: ${baseVersion}`);
          console.log(`   (package.json is at ${current}, but we use last tag ${lastTagVersion || 'none'} as base)`);
          
          // Get all commits since last release (or last 50 commits if no tag)
          let commitMessages = [];
          try {
            if (lastTag) {
              console.log(`\nüìã Collecting all commits between ${lastTag} and HEAD...`);
              const commits = cp.execSync(`git log ${lastTag}..HEAD --pretty=%B --no-merges --reverse`, { encoding: 'utf8' }).trim();
              commitMessages = commits.split('\n\n').filter(msg => msg.trim());
              console.log(`   Range: ${lastTag}..HEAD (exclusive of tag, inclusive of HEAD)`);
              console.log(`   Found ${commitMessages.length} commit(s) in range`);
              
              // Verify we got commits
              if (commitMessages.length === 0) {
                console.log('‚ö†Ô∏è  No commits found in range, checking if tag is at HEAD...');
                const tagCommit = cp.execSync(`git rev-parse ${lastTag}`, { encoding: 'utf8' }).trim();
                const headCommit = cp.execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim();
                console.log(`   Tag commit: ${tagCommit.substring(0, 7)}`);
                console.log(`   HEAD commit: ${headCommit.substring(0, 7)}`);
                if (tagCommit === headCommit) {
                  console.log('‚ÑπÔ∏è  Tag is at HEAD, no new commits since last release');
                }
              }
            } else {
              console.log('\nüìã No previous release tag found, getting ALL commits...');
              const commits = cp.execSync('git log --pretty=%B --no-merges', { encoding: 'utf8' }).trim();
              commitMessages = commits.split('\n\n').filter(msg => msg.trim());
              console.log(`   Found ${commitMessages.length} total commit(s) in repository`);
            }
          } catch (e) {
            console.log('‚ÑπÔ∏è  Could not get commits, using latest commit only');
            console.log('   Error:', e.message);
            let latestMsg = process.env.COMMIT_MSG || '';
            if (!latestMsg || latestMsg === 'null') {
              try { latestMsg = cp.execSync('git log -1 --pretty=%B').toString().trim(); } catch {}
            }
            commitMessages = [latestMsg];
          }
          
          console.log(`\nüìä Found ${commitMessages.length} commit(s) since last release (before filtering)`);
          
          // Debug: Show first few lines of each commit
          if (commitMessages.length > 0) {
            console.log('\nüìù Raw commits found:');
            commitMessages.slice(0, 5).forEach((msg, i) => {
              const firstLine = msg.split('\n')[0];
              console.log(`   ${i + 1}. ${firstLine.substring(0, 80)}`);
            });
            if (commitMessages.length > 5) {
              console.log(`   ... and ${commitMessages.length - 5} more`);
            }
          }
          
          // Helper function to check if a commit should be filtered out
          const shouldFilterCommit = (msg) => {
            const firstLine = msg.trim().split('\n')[0];
            
            // Check for version bump commits
            // Matches: "chore: bump version to 1.8.0 [skip ci]", "chore: bump version", "chore(release): ..."
            const isVersionBump = (
              /^chore\s*[:(]\s*bump\s+version/i.test(firstLine) ||
              /^chore\s*[:(]\s*release/i.test(firstLine) ||
              (msg.includes('[skip ci]') && /bump\s+version/i.test(msg))
            );
            
            // Check for [skip ci] flag
            const hasSkipCI = msg.includes('[skip ci]');
            
            return isVersionBump || hasSkipCI;
          };
          
          // Filter out version bump commits and [skip ci] commits
          const filteredCommitMessages = [];
          const filteredOutCommits = [];
          
          commitMessages.forEach((msg, index) => {
            const firstLine = msg.split('\n')[0];
            if (shouldFilterCommit(msg)) {
              const reason = /bump\s+version/i.test(msg) ? 'version bump' : '[skip ci]';
              filteredOutCommits.push({ index: index + 1, msg: firstLine.substring(0, 60), reason });
            } else {
              filteredCommitMessages.push(msg);
            }
          });
          
          // Log filtered commits for debugging
          if (filteredOutCommits.length > 0) {
            console.log(`\nüîç Filtered out ${filteredOutCommits.length} commit(s):`);
            filteredOutCommits.forEach(({ index, msg, reason }) => {
              console.log(`   ${index}. ${msg} (${reason})`);
            });
          }
          
          if (filteredCommitMessages.length === 0) {
            console.log('\n‚è≠Ô∏è  No relevant commits found (all commits were filtered out)');
            console.log(`   Total commits: ${commitMessages.length}, All were version bumps or [skip ci]`);
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `version=${current}\n`);
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `bump_type=skip\n`);
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `should_release=false\n`);
            process.exit(0);
          }
          
          // Use filtered commits for analysis
          commitMessages = filteredCommitMessages;
          
          console.log(`\nüìä Analyzing ${commitMessages.length} commit(s) since last release:`);
          commitMessages.forEach((msg, i) => {
            const firstLine = msg.split('\n')[0];
            console.log(`  ${i + 1}. ${firstLine.substring(0, 60)}${firstLine.length > 60 ? '...' : ''}`);
          });
          
          // Analyze all commits to determine bump type
          // COUNT each feat/fix for cumulative bumping (Plan B)
          let featCount = 0;
          let fixCount = 0;
          let hasBreaking = false;
          const commitTypes = [];
          
          commitMessages.forEach(msg => {
            const firstLine = msg.trim().split('\n')[0];
            let commitType = 'other';
            
            // Check for features (minor bump)
            if (/^(feat|feature)(\(|:)/i.test(firstLine)) {
              featCount++;
              commitType = 'feat';
            }
            // Check for fixes (patch bump)
            else if (/^(fix|bugfix)(\(|:)/i.test(firstLine)) {
              fixCount++;
              commitType = 'fix';
            }
            // Check for breaking changes
            if (msg.includes('BREAKING CHANGE') || /^[^:]+!:/.test(firstLine)) {
              hasBreaking = true;
              commitType = 'breaking';
            }
            // Check for refactor
            else if (/^refactor(\(|:)/i.test(firstLine)) {
              commitType = 'refactor';
            }
            // Check for chore
            else if (/^chore(\(|:)/i.test(firstLine)) {
              commitType = 'chore';
            }
            
            commitTypes.push(commitType);
          });
          
          console.log(`\nüìà Commit type analysis:`);
          console.log(`   Features: ${featCount} commit(s)`);
          console.log(`   Fixes: ${fixCount} commit(s)`);
          console.log(`   Breaking: ${hasBreaking ? '‚úÖ' : '‚ùå'}`);
          console.log(`   Other commits: ${commitMessages.length - featCount - fixCount}`);
          console.log(`   Types found: ${[...new Set(commitTypes)].join(', ')}`);
          
          // Determine bump type based on commit analysis
          // CRITICAL: Calculate bump from baseVersion (last tag), not current package.json
          // Cumulative bumping: Each feat/fix increments the version number
          let bump = 'build';
          const m = baseVersion.split('.').map(n => parseInt(n, 10) || 0);
          console.log(`\nüî¢ Version calculation from base ${baseVersion}:`);
          
          if (hasBreaking) {
            // Breaking changes ‚Üí major bump (resets minor/patch)
            console.log(`   Major: ${m[0]} ‚Üí ${m[0] + 1} (breaking change)`);
            m[0] += 1;
            m[1] = 0;
            m[2] = 0;
            bump = 'major';
            console.log('   üö® Result: Breaking changes ‚Üí major version bump');
          } else if (featCount > 0) {
            // Each feature increments minor version
            // Multiple features = multiple minor bumps (cumulative)
            console.log(`   Minor: ${m[1]} + ${featCount} features = ${m[1] + featCount}`);
            m[1] += featCount;
            m[2] = 0; // Reset patch
            bump = 'minor';
            console.log(`   ‚ú® Result: ${featCount} feature(s) ‚Üí minor +${featCount}`);
          } else if (fixCount > 0) {
            // Each fix increments patch version  
            // Multiple fixes = multiple patch bumps (cumulative)
            console.log(`   Patch: ${m[2]} + ${fixCount} fixes = ${m[2] + fixCount}`);
            m[2] += fixCount;
            bump = 'patch';
            console.log(`   üêõ Result: ${fixCount} fix(es) ‚Üí patch +${fixCount}`);
          } else {
            console.log('   ‚ÑπÔ∏è  No feat/fix commits ‚Üí no version change');
          }
          
          const next = bump === 'build' ? current : `${m[0]}.${m[1]}.${m[2]}`;
          const shouldRelease = bump !== 'build';
          
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `version=${next}\n`);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `bump_type=${bump}\n`);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `should_release=${shouldRelease}\n`);
          
          console.log(`\nüì¶ Version: ${baseVersion} ‚Üí ${next} (${bump})`);
          console.log(`   package.json was at ${current}, will be updated to ${next}`);
          if (shouldRelease) {
            console.log('‚úÖ Will create new release');
          } else {
            console.log('‚ÑπÔ∏è  Build-only (no version change)');
          }
          NODE

      - name: Check if version actually changed
        id: version_changed
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          NEW_VERSION=${{ steps.version_bump.outputs.version }}
          
          if [ "$CURRENT_VERSION" != "$NEW_VERSION" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Version will change: $CURRENT_VERSION ‚Üí $NEW_VERSION"
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  Version unchanged: $CURRENT_VERSION"
          fi

      - name: Apply version bump (update package.json)
        if: steps.version_changed.outputs.changed == 'true'
        run: |
          NEW_VERSION=${{ steps.version_bump.outputs.version }}
          
          # Update package.json
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '${NEW_VERSION}';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
            console.log('‚úÖ package.json updated to ${NEW_VERSION}');
          "
          
          echo "‚úÖ Version files updated to ${NEW_VERSION}"

      - name: Calculate version code for Android
        if: steps.version_changed.outputs.changed == 'true'
        id: version_code
        run: |
          VERSION=$(node -p "require('./package.json').version")
          VERSION_CODE=$(node -e "
            const v = '$VERSION'.split('.').map(n => parseInt(n, 10) || 0);
            const code = v[0] * 10000 + v[1] * 100 + v[2];
            console.log(code);
          ")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT
          echo "üì± Version: $VERSION ‚Üí Version Code: $VERSION_CODE"

      # -----------------------
      # Heavy steps only when releasing
      # -----------------------
      - name: Install dependencies
        if: steps.version_changed.outputs.changed == 'true'
        run: |
          yarn install --frozen-lockfile --prefer-offline --no-progress --network-timeout 100000
          echo "Dependencies installed successfully"

      - name: Setup Java
        if: steps.version_changed.outputs.changed == 'true'
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          check-latest: false

      - name: Setup Gradle (caching)
        if: steps.version_changed.outputs.changed == 'true'
        uses: gradle/actions/setup-gradle@v5
        with:
          add-job-summary: never

      - name: Setup Android SDK
        if: steps.version_changed.outputs.changed == 'true'
        uses: android-actions/setup-android@v3
        with:
          cmdline-tools-version: '11076708'
          accept-android-sdk-licenses: true
          log-accepted-android-sdk-licenses: false
          packages: 'platforms;android-36 build-tools;36.0.0 platform-tools'

      - name: Cache Expo tooling
        if: steps.version_changed.outputs.changed == 'true'
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            ~/.expo
            ~/.cache/expo
          key: ${{ runner.os }}-expo-${{ hashFiles('package.json', 'yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-expo-

      - name: Cache Metro bundler
        if: steps.version_changed.outputs.changed == 'true'
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            node_modules/.cache
            /tmp/metro-*
            android/app/build/generated/assets
            android/app/build/intermediates/sourcemaps
          key: ${{ runner.os }}-metro-${{ hashFiles('package.json', 'yarn.lock', 'app.config.*', 'app.json', 'babel.config.*', 'metro.config.*') }}
          restore-keys: |
            ${{ runner.os }}-metro-

      # Android files are now tracked in git, no prebuild needed
      # Version code is passed via ANDROID_VERSION_CODE env variable

      # Android files are tracked in git, versioning is handled via env variables

      - name: Make Gradle wrapper executable
        if: steps.version_changed.outputs.changed == 'true'
        run: chmod +x android/gradlew

      - name: Build Android APK (Release - Optimized)
        if: steps.version_changed.outputs.changed == 'true'
        working-directory: android
        run: |
          ./gradlew assembleRelease \
            --stacktrace \
            --no-daemon \
            -x lint \
            -x test \
            --build-cache \
            --parallel \
            --max-workers=4 \
            -Dorg.gradle.logging.level=quiet \
            -PreactNativeArchitectures=arm64-v8a \
            -Pandroid.enableProguardInReleaseBuilds=true \
            -Pandroid.enableMinifyInReleaseBuilds=true \
            -Pandroid.enableShrinkResourcesInReleaseBuilds=true \
            -Pandroid.useAndroidX=true \
            -Pandroid.enableR8.fullMode=true \
            -Pandroid.enableBundleCompression=true
          
          # Verify APK was created and check size
          APK_PATH="app/build/outputs/apk/release/"
          if [ -d "$APK_PATH" ]; then
            echo "‚úÖ APK build successful"
            du -h "$APK_PATH"*.apk 2>/dev/null || echo "APK files: $(ls -la $APK_PATH/*.apk | wc -l)"
          else
            echo "‚ö†Ô∏è  APK directory not found: $APK_PATH"
          fi
        env:
          # Version information
          ANDROID_VERSION_CODE: ${{ steps.version_code.outputs.version_code }}
          APP_VERSION: ${{ steps.version_code.outputs.version }}
          APP_VARIANT: 'release'
          # Node/React Native environment
          NODE_ENV: 'production'
          # These are already set in gradle.properties but can be overridden
          # ANDROID_ENABLE_PROGUARD_IN_RELEASE_BUILDS: 'true'
          # ANDROID_ENABLE_MINIFY_IN_RELEASE_BUILDS: 'true'
          # ANDROID_ENABLE_SHRINK_RESOURCES_IN_RELEASE_BUILDS: 'true'

      - name: List APK files
        if: steps.version_changed.outputs.changed == 'true'
        working-directory: android/app/build/outputs/apk/release
        run: |
          ls -lh *.apk
          if [ ! -f *.apk ]; then
            echo "‚ùå No APK files found!"
            exit 1
          fi

      - name: Rename APK with descriptive name
        if: steps.version_changed.outputs.changed == 'true'
        run: |
          cd android/app/build/outputs/apk/release
          APK_FILE=$(ls *.apk 2>/dev/null | head -n 1)
          if [ -z "$APK_FILE" ]; then
            echo "‚ùå No APK file found!"
            exit 1
          fi
          NEW_NAME="Safarnak-v${{ steps.version_code.outputs.version }}-build${{ github.run_number }}.apk"
          cp "$APK_FILE" "$NEW_NAME"
          ls -lh "$NEW_NAME"

      - name: Upload APK artifact
        if: steps.version_changed.outputs.changed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: safarnak-android-v${{ steps.version_code.outputs.version }}-build${{ github.run_number }}
          path: android/app/build/outputs/apk/release/Safarnak-v${{ steps.version_code.outputs.version }}-build${{ github.run_number }}.apk
          retention-days: 30
          compression-level: 0
          
      - name: Generate commit list for release notes
        if: steps.version_changed.outputs.changed == 'true'
        id: commits
        run: |
          # Fetch all tags to ensure we have the latest releases
          git fetch --tags --force 2>/dev/null || true
          
          # Get the latest release tag (matching pattern vX.Y.Z)
          LAST_TAG=$(git tag --sort=-version:refname | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+$" | head -n 1 || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            echo "‚ö†Ô∏è No previous release tag found, showing all commits"
            ALL_COMMITS=$(git log --oneline --no-decorate --format="%s|||%h|||%an|||%as" --no-merges)
          else
            echo "üìã Finding ALL commits since last release: $LAST_TAG"
            # Get ALL commits since last tag, excluding version bumps
            ALL_COMMITS=$(git log ${LAST_TAG}..HEAD --oneline --no-decorate --format="%s|||%h|||%an|||%as" --no-merges | \
              grep -v "chore: bump version" | \
              grep -v "chore(release)" | \
              grep -v "\[skip ci\]" || echo "")
          fi
          
          # Count commits by type for summary
          FEAT_COUNT=0
          FIX_COUNT=0
          OTHER_COUNT=0
          TOTAL_COUNT=0
          
          # Categorize commits by type
          FEATURES=""
          FIXES=""
          REFACTORS=""
          CHORES=""
          DOCS=""
          OTHERS=""
          
          while IFS='|||' read -r msg hash author date; do
            if [ -z "$msg" ]; then continue; fi
            TOTAL_COUNT=$((TOTAL_COUNT + 1))
            
            if [[ "$msg" =~ ^feat(\(|:)|^feature(\(|:) ]]; then
              FEATURES="${FEATURES}- ‚ú® ${msg} (\`${hash}\`)\n"
              FEAT_COUNT=$((FEAT_COUNT + 1))
            elif [[ "$msg" =~ ^fix(\(|:)|^bugfix(\(|:) ]]; then
              FIXES="${FIXES}- üêõ ${msg} (\`${hash}\`)\n"
              FIX_COUNT=$((FIX_COUNT + 1))
            elif [[ "$msg" =~ ^refactor(\(|:) ]]; then
              REFACTORS="${REFACTORS}- ‚ôªÔ∏è ${msg} (\`${hash}\`)\n"
              OTHER_COUNT=$((OTHER_COUNT + 1))
            elif [[ "$msg" =~ ^chore(\(|:) ]]; then
              CHORES="${CHORES}- üîß ${msg} (\`${hash}\`)\n"
              OTHER_COUNT=$((OTHER_COUNT + 1))
            elif [[ "$msg" =~ ^docs(\(|:) ]]; then
              DOCS="${DOCS}- üìù ${msg} (\`${hash}\`)\n"
              OTHER_COUNT=$((OTHER_COUNT + 1))
            elif [[ "$msg" =~ ^ci(\(|:) ]]; then
              CHORES="${CHORES}- üîß ${msg} (\`${hash}\`)\n"
              OTHER_COUNT=$((OTHER_COUNT + 1))
            else
              OTHERS="${OTHERS}- üî∏ ${msg} (\`${hash}\`)\n"
              OTHER_COUNT=$((OTHER_COUNT + 1))
            fi
          done <<< "$ALL_COMMITS"
          
          # Build summary
          SUMMARY="## üìä Summary\n\n"
          if [ -n "$LAST_TAG" ]; then
            SUMMARY="${SUMMARY}Changes since **${LAST_TAG}**:\n"
          fi
          SUMMARY="${SUMMARY}- **Total commits**: ${TOTAL_COUNT}\n"
          if [ $FEAT_COUNT -gt 0 ]; then
            SUMMARY="${SUMMARY}- **New features**: ${FEAT_COUNT}\n"
          fi
          if [ $FIX_COUNT -gt 0 ]; then
            SUMMARY="${SUMMARY}- **Bug fixes**: ${FIX_COUNT}\n"
          fi
          if [ $OTHER_COUNT -gt 0 ]; then
            SUMMARY="${SUMMARY}- **Other changes**: ${OTHER_COUNT}\n"
          fi
          SUMMARY="${SUMMARY}\n"
          
          # Build formatted output with all commits
          FORMATTED="${SUMMARY}"
          
          if [ -n "$FEATURES" ]; then
            FORMATTED="${FORMATTED}### ‚ú® New Features\n${FEATURES}\n"
          fi
          if [ -n "$FIXES" ]; then
            FORMATTED="${FORMATTED}### üêõ Bug Fixes\n${FIXES}\n"
          fi
          if [ -n "$REFACTORS" ]; then
            FORMATTED="${FORMATTED}### ‚ôªÔ∏è Refactoring\n${REFACTORS}\n"
          fi
          if [ -n "$DOCS" ]; then
            FORMATTED="${FORMATTED}### üìù Documentation\n${DOCS}\n"
          fi
          if [ -n "$CHORES" ]; then
            FORMATTED="${FORMATTED}### üîß Maintenance\n${CHORES}\n"
          fi
          if [ -n "$OTHERS" ]; then
            FORMATTED="${FORMATTED}### üî∏ Other Changes\n${OTHERS}\n"
          fi
          
          if [ -z "$FORMATTED" ] || [ "$TOTAL_COUNT" -eq 0 ]; then
            FORMATTED="No new commits since last release"
          fi
          
          echo "‚úÖ Generated release notes with ${TOTAL_COUNT} commits"
          echo -e "$FORMATTED" | head -100
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo -e "$FORMATTED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Commit version bump if changed
        if: steps.version_changed.outputs.changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add package.json
          git commit -m "chore: bump version to ${{ steps.version_code.outputs.version }} [skip ci]" || echo "No changes to commit"
          git push origin HEAD || echo "Push failed or unnecessary"

      - name: Create GitHub Release with APK
        if: steps.version_changed.outputs.changed == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version_code.outputs.version }}
          name: Safarnak v${{ steps.version_code.outputs.version }}
          body: |
            # üöÄ Safarnak v${{ steps.version_code.outputs.version }}

            > **ÿ≥ŸÅÿ±ŸÜÿß⁄©** - AI-powered offline-first travel companion

            **Version**: `${{ steps.version_code.outputs.version }}` | **Build**: #${{ github.run_number }} | **Version Code**: `${{ steps.version_code.outputs.version_code }}`

            ${{ steps.commits.outputs.commits }}
          files: android/app/build/outputs/apk/release/Safarnak-v${{ steps.version_code.outputs.version }}-build${{ github.run_number }}.apk
          draft: false
          prerelease: false
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup
        if: always()
        run: |
          rm -rf /tmp/metro-* || true
          find ~/.gradle/caches/ -name "*.lock" -type f -delete || true