/**
 * Client Database Adapter
 * 
 * Expo SQLite adapter for client-side offline database.
 * Provides database instance, Apollo cache sync, and statistics.
 * 
 * Usage:
 *   import { getLocalDB, syncApolloToDrizzle } from '@database/client';
 *   const db = await getLocalDB();
 *   await syncApolloToDrizzle(apolloCache);
 */

import * as SQLite from 'expo-sqlite';
import { drizzle } from 'drizzle-orm/expo-sqlite';
import { migrate } from 'drizzle-orm/expo-sqlite/migrator';
import { Platform } from 'react-native';
import { NormalizedCacheObject } from '@apollo/client';
import { eq, sql, isNotNull, desc } from 'drizzle-orm';
import {
  clientSchema,
  cachedUsers,
  cachedProfiles,
  cachedTrips,
  cachedPlaces,
  cachedMessages,
  cachedConversations,
  cachedChatMessages,
  pendingMutations,
  syncMetadata,
  apolloCacheEntries,
} from './schema';
import { formatRelativeTime } from '@hooks/useDateTime';
// Import migrations generated by drizzle-kit
import migrations from '@migrations/client/migrations';

// ============================================================================
// DATABASE INSTANCE
// ============================================================================

// Bump database name to get a clean DB (old DB is just cache, safe to reset)
const DATABASE_NAME = 'safarnak_local_v2.db';

let dbInstance: ReturnType<typeof drizzle> | null = null;
let initPromise: Promise<ReturnType<typeof drizzle>> | null = null;

/**
 * Get or initialize the local database instance
 * 
 * Automatically runs Drizzle migrations on first call.
 * Returns a shared promise to ensure migrations only run once.
 */
export async function getLocalDB(): Promise<ReturnType<typeof drizzle>> {
  if (dbInstance) return dbInstance;
  if (initPromise) {
    return initPromise;
  }
  initPromise = initializeDB();
  return initPromise;
}

async function initializeDB(): Promise<ReturnType<typeof drizzle>> {
  if (Platform.OS === 'web') {
    throw new Error('Web platform not yet supported. Use Apollo cache persistence for web.');
  }

  try {
    // Open database synchronously (Expo SQLite API)
    const sqlite = SQLite.openDatabaseSync(DATABASE_NAME);
    const db = drizzle(sqlite, { schema: clientSchema });

    // Run pending migrations using Drizzle migrator
    // Migrations are bundled into the JS bundle via babel-plugin-inline-import
    try {
      // Check if migrations object is valid and has actual migrations
      const hasMigrations = migrations && 
        typeof migrations === 'object' && 
        'migrations' in migrations && 
        Object.keys(migrations.migrations || {}).length > 0;
      
      if (hasMigrations) {
        await migrate(db, migrations);
        if (__DEV__) {
          console.log('✅ Database migrations completed');
        }
      } else {
        // If migrations are empty or invalid, create critical tables directly
        // This is a fallback when drizzle-kit hasn't generated migrations yet
        if (__DEV__) {
          console.warn('⚠️ No migrations found, creating critical tables directly');
        }
        // Create apollo_cache_entries table immediately (required for Apollo cache)
        await sqlite.execAsync(`
          CREATE TABLE IF NOT EXISTS apollo_cache_entries (
            key TEXT PRIMARY KEY NOT NULL,
            value TEXT NOT NULL,
            entity_type TEXT,
            entity_id TEXT,
            updated_at INTEGER DEFAULT (strftime('%s', 'now'))
          )
        `);
        if (__DEV__) {
          console.log('✅ Created apollo_cache_entries table');
        }
      }
    } catch (migrationError: any) {
      // Log migration errors but don't fail initialization
      // This allows the app to start even if migrations have issues
      console.error('❌ Database migration error:', migrationError?.message || migrationError);
      // Try to create critical tables as fallback
      try {
        await sqlite.execAsync(`
          CREATE TABLE IF NOT EXISTS apollo_cache_entries (
            key TEXT PRIMARY KEY NOT NULL,
            value TEXT NOT NULL,
            entity_type TEXT,
            entity_id TEXT,
            updated_at INTEGER DEFAULT (strftime('%s', 'now'))
          )
        `);
        if (__DEV__) {
          console.log('✅ Created apollo_cache_entries table as fallback');
        }
      } catch (fallbackError) {
        console.error('❌ Failed to create fallback tables:', fallbackError);
        throw migrationError; // Re-throw original error
      }
    }

    dbInstance = db;
    // Silent initialization - no logs to avoid cluttering boot
    return db;
  } catch (error) {
    console.error('❌ Failed to initialize local database:', error);
    throw error;
  }
}

// Export schema for use in queries
export const schema = clientSchema;

// ============================================================================
// APOLLO CACHE SYNC
// ============================================================================

const ENTITY_TYPE_TO_TABLE = {
  User: cachedUsers,
  Profile: cachedProfiles, // Added Profile support
  Trip: cachedTrips,
  // Tour removed - unified into Trip with isHosted flag
  Place: cachedPlaces,
  Message: cachedMessages,
  Conversation: cachedConversations,
  ChatMessage: cachedChatMessages,
  // TripParticipant, TripDay, TripItem are not directly cached via Apollo cache
  // They are nested within Trip entities and handled separately
} as const;

type EntityType = keyof typeof ENTITY_TYPE_TO_TABLE;

/**
 * Sync Apollo normalized cache to Drizzle local database
 * 
 * @deprecated This function is no longer needed. DrizzleCacheStorage automatically
 * syncs to structured tables when Apollo writes to cache. This function is kept
 * for backward compatibility and migration purposes only.
 */
export async function syncApolloToDrizzle(cache: NormalizedCacheObject): Promise<void> {
  try {
    const db = await getLocalDB();
    const now = Math.floor(Date.now() / 1000);

    for (const [key, data] of Object.entries(cache)) {
      if (!data || typeof data !== 'object') continue;

      const match = key.match(/^([A-Z][a-zA-Z]*):(.+)$/);
      if (!match) continue;

      const [, entityType, _entityId] = match;
      if (!(entityType in ENTITY_TYPE_TO_TABLE)) continue;

      const table = ENTITY_TYPE_TO_TABLE[entityType as EntityType];
      const transformed = transformEntity(entityType as EntityType, data);
      if (!transformed) continue;

      await upsertEntity(db, table, transformed, now);
    }

    if (__DEV__) {
      console.log('✅ Synced Apollo cache to Drizzle');
    }
  } catch (error) {
    console.error('❌ Failed to sync Apollo cache to Drizzle:', error);
    throw error;
  }
}

function transformEntity(entityType: EntityType, data: any): Record<string, any> | null {
  try {
    switch (entityType) {
      case 'User':
        return {
          id: String(data.id || ''),
          name: data.name || '',
          username: data.username || '',
          email: data.email || null,
          phone: data.phone || null,
          avatar: data.avatar || null,
          isActive: data.isActive !== false,
          createdAt: data.createdAt || new Date().toISOString(),
          updatedAt: data.updatedAt || new Date().toISOString(),
        };
      case 'Trip':
        return {
          id: String(data.id || ''),
          userId: String(data.userId || ''),
          title: data.title || null,
          destination: data.destination || null,
          startDate: data.startDate || null,
          endDate: data.endDate || null,
          budget: data.budget ? parseInt(String(data.budget), 10) : null, // Integer for minor units
          travelers: data.travelers || 1,
          preferences: data.preferences || null,
          accommodation: data.accommodation || null,
          status: data.status || 'in_progress',
          aiReasoning: data.aiReasoning || null,
          itinerary: data.itinerary ? JSON.stringify(data.itinerary) : null,
          coordinates: data.coordinates ? JSON.stringify(data.coordinates) : null,
          waypoints: data.waypoints ? JSON.stringify(data.waypoints) : null,
          // Hosted trip fields
          isHosted: data.isHosted === true,
          location: data.location || null,
          price: data.price ? parseFloat(String(data.price)) : null,
          currency: data.currency || 'USD',
          rating: data.rating ? parseFloat(String(data.rating)) : 0,
          reviews: parseInt(String(data.reviews || 0), 10),
          duration: data.duration ? parseInt(String(data.duration), 10) : null,
          durationType: data.durationType || 'days',
          category: data.category || null,
          difficulty: data.difficulty || null,
          description: data.description || null,
          shortDescription: data.shortDescription || null,
          highlights: data.highlights ? JSON.stringify(data.highlights) : null,
          inclusions: data.inclusions ? JSON.stringify(data.inclusions) : null,
          maxParticipants: data.maxParticipants ? parseInt(String(data.maxParticipants), 10) : null,
          minParticipants: parseInt(String(data.minParticipants || 1), 10),
          hostIntro: data.hostIntro || null,
          joinPolicy: data.joinPolicy || 'open',
          bookingInstructions: data.bookingInstructions || null,
          imageUrl: data.imageUrl || null,
          gallery: data.gallery ? JSON.stringify(data.gallery) : null,
          tags: data.tags ? JSON.stringify(data.tags) : null,
          isActive: data.isActive !== false,
          isFeatured: data.isFeatured === true,
          externalBookingUrl: data.externalBookingUrl || null,
          createdAt: data.createdAt || new Date().toISOString(),
          updatedAt: data.updatedAt || new Date().toISOString(),
        };
      case 'Profile':
        return {
          id: String(data.id || ''),
          userId: String(data.userId || ''),
          displayName: data.displayName || null,
          bio: data.bio || null,
          avatarUrl: data.avatarUrl || null,
          phone: data.phone || null,
          homeBase: data.homeBase || null,
          travelStyle: data.travelStyle || null,
          languages: data.languages ? JSON.stringify(data.languages) : null,
          isActive: data.isActive !== false,
          createdAt: data.createdAt || new Date().toISOString(),
          updatedAt: data.updatedAt || new Date().toISOString(),
        };
      // Tour removed - unified into Trip with isHosted flag
      case 'Place':
        return {
          id: String(data.id || ''),
          name: data.name || '',
          location: data.location || '',
          distance: data.distance ? parseFloat(String(data.distance)) : null,
          rating: parseFloat(String(data.rating || 0)),
          reviews: parseInt(String(data.reviews || 0), 10),
          type: data.category || data.type || '',
          isOpen: data.isOpen !== false,
          description: data.description || '',
          tips: data.tips ? JSON.stringify(data.tips) : null,
          coordinates: data.coordinates ? JSON.stringify(data.coordinates) : null,
          phone: data.phone || null,
          website: data.website || null,
          hours: data.hours || null,
          createdAt: data.createdAt || new Date().toISOString(),
          updatedAt: data.updatedAt || new Date().toISOString(),
        };
      case 'Message':
        return {
          id: String(data.id || ''),
          content: data.content || '',
          userId: data.userId ? String(data.userId) : null,
          type: data.type || 'text',
          metadata: data.metadata ? JSON.stringify(data.metadata) : null,
          isRead: data.isRead === true,
          createdAt: data.createdAt || new Date().toISOString(),
        };
      case 'Conversation':
        return {
          id: String(data.id || ''),
          kind: data.kind || 'DM',
          tripId: data.tripId ? String(data.tripId) : null,
          title: data.title || null,
          lastMessagePreview: data.lastMessagePreview || null,
          lastMessageAt: data.lastMessageAt || null,
          createdAt: data.createdAt || new Date().toISOString(),
          updatedAt: data.updatedAt || new Date().toISOString(),
        };
      case 'ChatMessage':
        return {
          id: String(data.id || ''),
          conversationId: String(data.conversationId || ''),
          senderUserId: String(data.senderUserId || ''),
          senderDeviceId: String(data.senderDeviceId || ''),
          ciphertext: data.ciphertext || '',
          ciphertextMeta: data.ciphertextMeta ? JSON.stringify(data.ciphertextMeta) : null,
          type: data.type || 'text',
          metadata: data.metadata ? JSON.stringify(data.metadata) : null,
          createdAt: data.createdAt || new Date().toISOString(),
        };
      default:
        return null;
    }
  } catch (error) {
    if (__DEV__) {
      console.warn(`Failed to transform ${entityType}:`, error);
    }
    return null;
  }
}

async function upsertEntity(
  db: Awaited<ReturnType<typeof getLocalDB>>,
  table: any,
  data: Record<string, any>,
  now: number
): Promise<void> {
  try {
    const existing = await db.select().from(table).where(eq(table.id, data.id)).limit(1);
    const record = { ...data, lastSyncAt: now, pending: false };

    if (existing.length > 0) {
      await db
        .update(table)
        .set({ ...record, cachedAt: existing[0].cachedAt || now })
        .where(eq(table.id, data.id));
    } else {
      await db.insert(table).values({ ...record, cachedAt: now });
    }
  } catch (error) {
    if (__DEV__) {
      console.warn(`Failed to upsert ${data.id}:`, error);
    }
  }
}

// ============================================================================
// DATABASE STATISTICS
// ============================================================================

export interface EntityStats {
  count: number;
  pendingCount: number;
  deletedCount: number;
  lastSyncAt: number | null;
  oldestCachedAt: number | null;
  newestCachedAt: number | null;
}

export interface ApolloCacheStats {
  totalEntries: number;
  entityEntries: number;
  rootEntries: number;
  totalSize: number;
  oldestEntry: number | null;
  newestEntry: number | null;
  entriesByType: Record<string, number>;
}

export interface DatabaseStats {
  entities: {
    trips: EntityStats;
    users: EntityStats;
    messages: EntityStats;
    places: EntityStats;
    conversations: EntityStats;
    chatMessages: EntityStats;
  };
  totalEntities: number;
  apolloCache: ApolloCacheStats;
  pendingMutations: {
    total: number;
    withErrors: number;
    oldestQueuedAt: number | null;
  };
  syncStatus: Array<{
    entityType: string;
    lastSyncAt: number | null;
    schemaVersion: number;
  }>;
  storage: {
    totalSize: number;
    apolloCacheSize: number;
    structuredDataSize: number;
  };
}

/**
 * Get comprehensive database statistics
 */
export async function getDatabaseStats(): Promise<DatabaseStats> {
  try {
    const db = await getLocalDB();

    // Helper to get entity stats
    const getEntityStats = async (table: any, hasPending = false, hasDeleted = false) => {
      const [count] = await db.select({ count: sql<number>`count(*)` }).from(table);
      const [lastSync] = await db.select({ lastSync: sql<number>`max(${table.lastSyncAt})` }).from(table);
      const [cachedRange] = await db
        .select({
          oldest: sql<number>`min(${table.cachedAt})`,
          newest: sql<number>`max(${table.cachedAt})`,
        })
        .from(table);

      let pendingCount = 0;
      if (hasPending) {
        const [pending] = await db.select({ count: sql<number>`count(*)` }).from(table).where(eq(table.pending, true));
        pendingCount = pending?.count || 0;
      }

      let deletedCount = 0;
      if (hasDeleted) {
        const [deleted] = await db.select({ count: sql<number>`count(*)` }).from(table).where(isNotNull(table.deletedAt));
        deletedCount = deleted?.count || 0;
      }

      return {
        count: count?.count || 0,
        pendingCount,
        deletedCount,
        lastSyncAt: lastSync?.lastSync || null,
        oldestCachedAt: cachedRange?.oldest || null,
        newestCachedAt: cachedRange?.newest || null,
      };
    };

    const [trips, users, messages, places, conversationsStats, chatMessagesStats] = await Promise.all([
      getEntityStats(cachedTrips, true, true),
      getEntityStats(cachedUsers, true, false),
      getEntityStats(cachedMessages, true, false),
      getEntityStats(cachedPlaces, false, false),
      getEntityStats(cachedConversations, true, false),
      getEntityStats(cachedChatMessages, true, false),
    ]);

    const [pendingTotal] = await db.select({ count: sql<number>`count(*)` }).from(pendingMutations);
    const [pendingWithErrors] = await db.select({ count: sql<number>`count(*)` }).from(pendingMutations).where(isNotNull(pendingMutations.lastError));
    const [pendingOldest] = await db.select({ oldest: sql<number>`min(${pendingMutations.queuedAt})` }).from(pendingMutations);
    const syncStatus = await db.select().from(syncMetadata);

    // Get Apollo cache statistics
    const [apolloTotal] = await db.select({ count: sql<number>`count(*)` }).from(apolloCacheEntries);
    const [apolloEntityCount] = await db.select({ count: sql<number>`count(*)` }).from(apolloCacheEntries).where(isNotNull(apolloCacheEntries.entityType));
    const [apolloRootCount] = await db.select({ count: sql<number>`count(*)` }).from(apolloCacheEntries).where(sql`${apolloCacheEntries.entityType} IS NULL`);
    const [apolloSize] = await db.select({ totalSize: sql<number>`SUM(LENGTH(${apolloCacheEntries.value}))` }).from(apolloCacheEntries);
    const [apolloTimeRange] = await db.select({
      oldest: sql<number>`min(${apolloCacheEntries.updatedAt})`,
      newest: sql<number>`max(${apolloCacheEntries.updatedAt})`,
    }).from(apolloCacheEntries);
    
    // Get entries by entity type
    const entriesByTypeResult = await db
      .select({
        entityType: apolloCacheEntries.entityType,
        count: sql<number>`count(*)`,
      })
      .from(apolloCacheEntries)
      .where(isNotNull(apolloCacheEntries.entityType))
      .groupBy(apolloCacheEntries.entityType);
    
    const entriesByType: Record<string, number> = {};
    entriesByTypeResult.forEach((row) => {
      if (row.entityType) {
        entriesByType[row.entityType] = Number(row.count || 0);
      }
    });

    const apolloCacheStats: ApolloCacheStats = {
      totalEntries: Number(apolloTotal?.count || 0),
      entityEntries: Number(apolloEntityCount?.count || 0),
      rootEntries: Number(apolloRootCount?.count || 0),
      totalSize: Number(apolloSize?.totalSize || 0),
      oldestEntry: apolloTimeRange?.oldest || null,
      newestEntry: apolloTimeRange?.newest || null,
      entriesByType,
    };

    // Calculate structured data size (approximate)
    const structuredDataSize = apolloCacheStats.totalSize; // For now, use same as cache size

    return {
      entities: {
        trips,
        users,
        messages,
        places,
        conversations: conversationsStats,
        chatMessages: chatMessagesStats,
      },
      totalEntities:
        trips.count + users.count + messages.count + places.count + conversationsStats.count + chatMessagesStats.count,
      apolloCache: apolloCacheStats,
      pendingMutations: {
        total: pendingTotal?.count || 0,
        withErrors: pendingWithErrors?.count || 0,
        oldestQueuedAt: pendingOldest?.oldest || null,
      },
      syncStatus: syncStatus.map((s) => ({
        entityType: s.entityType,
        lastSyncAt: s.lastSyncAt || null,
        schemaVersion: s.schemaVersion || 1,
      })),
      storage: {
        totalSize: apolloCacheStats.totalSize + structuredDataSize,
        apolloCacheSize: apolloCacheStats.totalSize,
        structuredDataSize,
      },
    };
  } catch (error) {
    console.error('Failed to get database stats:', error);
    const empty = { count: 0, pendingCount: 0, deletedCount: 0, lastSyncAt: null, oldestCachedAt: null, newestCachedAt: null };
    return {
      entities: { trips: empty, users: empty, messages: empty, places: empty, conversations: empty, chatMessages: empty },
      totalEntities: 0,
      pendingMutations: { total: 0, withErrors: 0, oldestQueuedAt: null },
      syncStatus: [],
      apolloCache: {
        totalEntries: 0,
        entityEntries: 0,
        rootEntries: 0,
        totalSize: 0,
        oldestEntry: null,
        newestEntry: null,
        entriesByType: {},
      },
      storage: { totalSize: 0, apolloCacheSize: 0, structuredDataSize: 0 },
    };
  }
}

/**
 * Get pending mutations with details
 */
export async function getPendingMutationsDetails() {
  try {
    const db = await getLocalDB();
    return await db.select().from(pendingMutations).orderBy(desc(pendingMutations.queuedAt)).limit(10);
  } catch (error) {
    console.error('Failed to get pending mutations details:', error);
    return [];
  }
}

/**
 * Format timestamp to human-readable relative time format
 * Uses datetime helper for proper localization
 * 
 * @param timestamp - Unix timestamp in seconds (not milliseconds)
 * @param language - Language code (e.g., 'en', 'fa') - defaults to 'en'
 * @returns Formatted relative time string (e.g., "9 days ago" or "۹ روز پیش")
 */
export function formatTimestamp(timestamp: number | null, language: string = 'en'): string {
  if (!timestamp) return 'Never';
  
  // Convert Unix timestamp (seconds) to Date object for datetime helper
  // Multiply by 1000 to convert seconds to milliseconds for Date
  const date = new Date(timestamp * 1000);
  
  // Use formatRelativeTime directly (can't use hook in utility function)
  // Language parameter allows callers to specify language for localization
  return formatRelativeTime(date, language);
}
